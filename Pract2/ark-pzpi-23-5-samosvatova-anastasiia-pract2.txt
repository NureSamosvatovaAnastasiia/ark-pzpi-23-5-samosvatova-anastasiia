МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з практичного заняття №2 з дисципліни
аналіз та рефакторінг коду




Виконала:                                                                           Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Самосватова А.Р.						          Сокорчук Ігор Петрович



Харків 2025
ІСТОРІЯ ЗМІН
      №      ДатаВерсія звіту      Опис змін та виправлень      1      19.10.2025      0.1      Початкова версія



1 МЕТА РОБОТИ
     Дослідити та проаналізувати проблеми в коді, що виникають у процесі розробки веб-проєктів, та продемонструвати практичне застосування трьох конкретних методів рефакторингу: «Заміна коду помилки винятком», «Консолідація умовного виразу» та «Консолідація дубльованих фрагментів в умовах».
     2 ОПИС ВИКОНАНОЇ РОБОТИ
     Рефакторинг є невід'ємною частиною розробки програмного забезпечення. Це дисциплінований процес, що полягає у покращенні внутрішньої структури існуючого коду, при цьому не змінюючи його зовнішньої поведінки. 
     Ключові цілі цього процесу багатогранні: по-перше, це підвищення читабельності коду, що робить його легшим для розуміння іншими розробниками та самим автором у майбутньому. По-друге, це спрощення подальшої підтримки, оскільки зменшення складності та усунення дублювання логіки значно полегшує процес виправлення помилок. По-третє, це забезпечення гнучкості коду, адже добре структуровану систему легше розширювати та додавати до неї нову функціональність. У даній роботі буде розглянуто три специфічні методи рефакторингу, що часто застосовуються у веб-проектах: заміна коду помилки винятком (Replace Error Code with Exception), консолідація умовного виразу (Consolidate Conditional Expression) та консолідація дубльованих фрагментів в умовах (Consolidate Duplicate Conditional Fragments). Кожен метод буде проаналізовано на конкретних прикладах.
     Перша проблема, яку буде розглянуто, стосується поширеної практики використання "магічних" значень для сигналізації про помилку. У Python-проєктах такою "чарівною" константою найчастіше виступає None. Наприклад, функція get_user_profile (рядок 1-14), що має дістати користувача з бази даних, може повертати None, якщо користувача не знайдено. 
     
1. def is_discount_eligible(user):
2.     # Умова 1
3.     if user.is_vip:
4.         return True
5.     
6.     # Умова 2
7.     if user.order_count == 0:
8.         return True
9.     
10.     # Умова 3
11.     if is_black_friday():
12.         return True
13.         
14.     return False
     
     Це створює серйозні недоліки. По-перше, це ненадійно. Клієнтський код, наприклад, контролер у веб-фреймворку, який викликає цю функцію, зобов'язаний щоразу пам'ятати про перевірку if profile is None:. Якщо розробник забуде це зробити і спробує звернутися до атрибуту, наприклад profile.name, програма впаде з AttributeError: 'NoneType' object has no attribute 'name'. По-друге, такий підхід засмічує код, оскільки "щасливий шлях", тобто логіка успішного виконання, перемішується з логікою обробки помилок, що значно погіршує читабельність основного алгоритму.
     Рішення цієї проблеми полягає в тому, щоб функція замість повернення None генерувала семантичний виняток (Exception), наприклад, ProfileNotFoundError. Це ідіоматичний та набагато потужніший підхід в Python. У такому випадку клієнтський код (рядок 1-14) радикально змінюється: основна логіка обгортається у блок try, а обробка помилкової ситуації виноситься у блок except ProfileNotFoundError:

1. class ProfileNotFoundError(Exception): pass
2. 
3. def get_user_profile(user_id):
4.     profile_data = db.users.get(user_id)
5.     if profile_data:
6.         return profile_data
7.     else:
8.         raise ProfileNotFoundError() # <-- Генеруємо виняток
9. 
10. # У контролері:
11. try:
12.     profile = get_user_profile(user_id)
13. except ProfileNotFoundError:
14.     return {"error": "Not found"}, 404 # <-- Обробка помилки

     Переваги такого рефакторингу є суттєвими. По-перше, це надійність: виняток, на відміну від значення None, неможливо випадково проігнорувати; необроблений виняток негайно зупинить програму, що є кращим, ніж прихована помилка. По-друге, це чистота коду: ми отримуємо чітке візуальне та логічне розділення основного потоку виконання та коду обробки помилок. По-третє, це інформативність: семантичний клас винятку ProfileNotFoundError несе набагато більше сенсу для розробника та систем моніторингу, ніж абстрактне значення None.
     Другий метод рефакторингу стосується ситуацій, коли декілька окремих умовних блоків (if) у межах однієї функції призводять до однакового результату. Наприклад, функція is_discount_eligible (рядок 1-14), що перевіряє право користувача на знижку, може містити один if, що перевіряє user.is_vip і повертає True, за ним інший if, що перевіряє user.order_count == 0 і теж повертає True, і третій, що перевіряє is_black_friday() і теж повертає True.
1. def is_discount_eligible(user):
2.     # Умова 1
3.     if user.is_vip:
4.         return True
5.     
6.     # Умова 2
7.     if user.order_count == 0:
8.         return True
9.     
10.     # Умова 3
11.     if is_black_friday():
12.         return True
13.         
14.     return False

     Це створює проблему фрагментації логіки. Щоб зрозуміти повне бізнес-правило "Хто має право на знижку?", розробнику потрібно "просканувати" всю функцію і зібрати ці умови докупи у своїй голові. Це також значно ускладнює підтримку: додавання нової умови (наприклад, "знижка на день народження") вимагає пошуку правильного місця для ще одного блоку if або модифікації одного з існуючих, що збільшує безлад.
     Рішення полягає в тому, щоб об'єднати всі ці розрізнені умови в один-єдиний логічний вираз за допомогою оператора or. Функція is_discount_eligible (рядок 1-6)  після рефакторингу матиме лише один return. Для того, щоб цей складний вираз не втратив читабельності, кожну під-умову можна винести в окрему змінну з описовою назвою, наприклад: is_vip_user = user.is_vip, is_new_user = (user.order_count == 0), is_promo_day = is_black_friday(). Тоді фінальний вираз return is_vip_user or is_new_user or is_promo_day стає самодокументованим.
     
         1. def is_discount_eligible(user):
         2.     is_vip_user = user.is_vip
         3.     is_new_user = (user.order_count == 0)
         4.     is_promo_day = is_black_friday()
         5.     
         6.     return is_vip_user or is_new_user or is_promo_day

     Переваги очевидні: вся бізнес-логіка стає прозорою і централізованою в одному місці. Підтримка такого коду стає тривіальною: додати нове правило — це просто додати ще один or та нову змінну в одному логічному блоці. Код стає значно чистішим та виразнішим. 
     Третій метод вирішує класичне порушення принципу DRY (Don't Repeat Yourself). Проблема виникає, коли один і той самий рядок або навіть цілий блок коду повторюється у всіх гілках умовного оператора, наприклад, і в if, і в else. Уявімо функцію calculate_shipping (рядок 1-12), де в блоці if user.is_premium_member: встановлюється shipping_cost = 0 і виконується рядок логування print("Розрахунок доставки..."), а в блоці else: встановлюється shipping_cost = 100 і виконується точно такий самий рядок логування.

       1. def calculate_shipping(order, user):
       2.     if user.is_premium_member:
       3.         shipping_cost = 0
       4.         print(f"Розрахунок для {order.id}...")
       5.  # <-- ДУБЛІКАТ 1
       6.     else:
       7.         shipping_cost = 100
       8.         print(f"Розрахунок для {order.id}...") 
       9. # <-- ДУБЛІКАТ 2
       10.     
       11.     order.shipping = shipping_cost
       12.     return shipping_cost
     
     Це не просто естетичний недолік, це небезпечна пастка для підтримки. Існує високий ризик, що в майбутньому розробник оновить формат логування в if-блоці, але забуде зробити ідентичну зміну в else-блоці, що призведе до неузгодженої поведінки та ускладнить налагодження.
     Рішення цієї проблеми є логічним і простим: необхідно винести дубльований код за межі умовного блоку. Якщо цей код (як у прикладі з логуванням) має виконатися незалежно від того, яка умова істинна, його слід перемістити перед блоком if...else. Якщо ж дубльований код залежить від результатів обчислень всередині гілок, його слід розмістити після блоку. У прикладі з calculate_shipping (рядок 1-10) треба просто перенести рядок print("Розрахунок доставки...") на один рівень вище, перед if.
     
1. def calculate_shipping(order, user):
2.     # Код винесено НА ПОЧАТОК, бо він спільний
3.     print(f"Розрахунок для {order.id}...")
4.     
5.     if user.is_premium_member:
6.         shipping_cost = 0
7.     else:
8.         shipping_cost = 100
9.     order.shipping = shipping_cost
10.     return shipping_cost

     Переваги такого рефакторингу дуже помітні: по-перше, відновлено дотримання принципу DRY. По-друге, код стає надійнішим для підтримки, оскільки тепер для зміни логування потрібно відредагувати лише один рядок. По-третє, покращується читабельність: умовний блок стає чистішим і демонструє лише те, що дійсно відрізняється між гілками — у даному випадку, логіку визначення змінної shipping_cost.
     ВИСНОВКИ
     Систематичне застосування рефакторингу не є "втратою часу", а є важливою інвестицією в якість та довгострокову життєздатність веб-проєкту. Розглянуті методи демонструють, як цілеспрямовані зміни покращують ключові аспекти коду, що є особливо актуальним для Python, враховуючи його філософію, орієнтовану на читабельність.
     В контексті веб-розробки, заміна кодів помилок на винятки безпосередньо підвищила надійність системи. Консолідація умовних виразів зробила бізнес-логіку прозорою, централізованою та легкою для модифікації. Усунення дублікатів з умовних блоків, які часто зустрічаються в логіці обробки запитів, спростило підтримку коду та знизило ризик внесення помилок у майбутньому.
     Загальний результат застосування цих технік - це чистіший, гнучкіший до змін та значно легший для розуміння Python-код, з яким приємніше та ефективніше працювати в динамічному та ітеративному процесі веб-розробки.


     ДОДАТОК А
     Посилання на YouTube
Відеозапис презентації результатів практичного заняття: 

Таймкоди:
00:00 - Вступне представлення та тема доповіді
00:07 – Важливість написання чистого коду
01:02 – Правильна структура коду 
01:40 – Форматування коду 
02:26 – Іменування змінних
03:34 – Коментарі
04:19 – Документування коду
05:43 – Конвенції стилю кодування
06:59 – Кодування на основі тестування
08:06 – Інструменти та автоматизація для підтримки якості коду
09:15 – Приклади оформлення коду
10:27 – Висновки













    ДОДАТОК Б
    Графічні матеріали 
    

Рисунок Б.1 — Титульний слайд


Рисунок Б.2 — Слайд про мету рефакторіну

Рисунок Б.3 — Проблему для заміни коду помилки винятком


Рисунок Б.4 — Використання заміни коду помилки винятком

Рисунок Б.5 — Проблема для використання консолідації умовного виразу


Рисунок Б.6 — Використання консолідації умовного виразу


Рисунок Б.7 — Проблема для використання консолідації дубльованих фрагментів


Рисунок Б.8 — Використання консолідації дубльованих фрагментів


Рисунок Б.9 — Висновки


Рисунок Б.10 — Використані джерела





